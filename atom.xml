<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alcex</title>
  
  <subtitle>你所热爱的，就是你的生活</subtitle>
  <link href="https://blog.alcex.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.alcex.cn/"/>
  <updated>2024-05-04T17:38:29.306Z</updated>
  <id>https://blog.alcex.cn/</id>
  
  <author>
    <name>Alcex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>零成本为网站增加 ipv6 支持</title>
    <link href="https://blog.alcex.cn/posts/20240504a/"/>
    <id>https://blog.alcex.cn/posts/20240504a/</id>
    <published>2024-05-04T07:38:58.740Z</published>
    <updated>2024-05-04T17:38:29.306Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两年随着国家的大力支持，三大运营商已经开始普及IPv6，ipv6 的成本越来越低，为了紧跟时代步伐，不少网站已开启 IPv6 访问</p></blockquote><p>开启 IPv6，本期来讲讲如何为不支持 ipv6 的网站增加 ipv6 支持</p><details ><summary>若你使用的是服务器且服务器支持ipv6</summary><div class="content"><p>一、分配 IPv6 地址</p><p>如果你的服务器支持 IPv6 ，但是在创建的时候没有添加 IPv6 地址，请先添加后再操作。</p><p>不同服务器厂商添加方法可能不一样，可咨询客服。</p><p>有 IPv6 地址后，Linux系统在终端输入 ip addr， 会有类似输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">inet6 240b:4001:1:400:e72d:dab:c902:b662/64 scope global</span><br><span class="line"></span><br><span class="line"> valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">inet6 fe80::216:3eff:fe01:c27b/64 scope link</span><br><span class="line"></span><br><span class="line"> valid_lft forever preferred_lft forever</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以在服务器运营商后台查看，比如 Vultr 直接查看服务器详细信息 settings 就可以找到</p><p>根据IPv6 规范，必须要有两个 IPv6 地址，其中 global 是公网访问的， 而 link 是本地的地址。如果没有输出 global，说明没有公网IPv6 地址，请咨询 vps 运营商帮忙处理。</p><p>二、开启 IPv6 监听</p><p>配置 web 服务器 （Nginx 、Apache） 监听 IPv6 流量</p><p>以 Nginx 为例，编辑网站配置文件</p><p>查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">listen 80;</span><br><span class="line"></span><br><span class="line">listen 443 ssl http2;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>替换为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">listen 80;</span><br><span class="line"></span><br><span class="line">listen [::]:80;</span><br><span class="line"></span><br><span class="line">listen 443 ssl http2;</span><br><span class="line"></span><br><span class="line">listen [::]:443 ssl http2;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重启 Nginx</p><p>三、添加 AAAA 解析指向 ipv6 地址</p></div></details><details ><summary>若你使用的是服务器但服务器不支持ipv6</summary><div class="content"><p>参考 <em>Cloudflare WARP 教程：给 VPS 额外添加“原生” IPv4&#x2F;IPv6 双栈网络出口</em></p><a class="tag-link" target="_blank" href="https://p3terx.com/archives/use-cloudflare-warp-to-add-extra-ipv4-or-ipv6-network-support-to-vps-servers-for-free.html">    <div class="tag-link-tips">引用站外链接</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/p3terx.com.png)">            <i class="solitude st-link-m-line" style="display: none"></i>        </div>        <div class="tag-link-right">            <div class="tag-link-title">P3TERX ZONE</div>            <div class="tag-link-sitename">Cloudflare WARP 教程：给 VPS 额外添加“原生” IPv4/IPv6 双栈网络出口</div>        </div>        <i class="solitude st-arrow-right-bold"></i>    </div>    </a></div></details><h3 id="若你使用的是不支持-ipv6-的托管平台"><a href="#若你使用的是不支持-ipv6-的托管平台" class="headerlink" title="若你使用的是不支持 ipv6 的托管平台"></a>若你使用的是不支持 ipv6 的托管平台</h3><p>比如我使用的是 vercel ，之前有人曾在 vercel 官方讨论区提到过 支持 ipv6 但官方最后找了个理由搪塞过去了（<a href="https://github.com/orgs/vercel/discussions/47%EF%BC%89">https://github.com/orgs/vercel/discussions/47）</a></p><p>于是便发现 netifly 与 cloudflare 支持 ipv6</p><p>测速发现 netifly 有七个节点支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2406:da18:b3d:e201::64 （新加坡）</span><br><span class="line"></span><br><span class="line">2406:da18:880:3800::c8 （新加坡）</span><br><span class="line"></span><br><span class="line">2406:da18:880:3802::c8 （新加坡）</span><br><span class="line"></span><br><span class="line">2406:da18:b3d:e202::64 （新加坡）</span><br><span class="line"></span><br><span class="line">2406:da18:880:3801::c8（新加坡）</span><br><span class="line"></span><br><span class="line">2406:da18:b3d:e200::64（新加坡）</span><br><span class="line"></span><br><span class="line">2600:1f1c:471:9d01::c8（美国旧金山）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>速度还算可以，附图</p><p><img src="https://bu.dusays.com/2024/05/04/6636528f77f4d.jpg" alt="Screenshot_20240504_231918.jpg"></p><p>随后添加AAAA解析</p><p><img src="https://bu.dusays.com/2024/05/04/663652c9a15d9.jpg" alt="Screenshot_20240504_232240.jpg"></p><p>最后效果：</p><p><img src="https://bu.dusays.com/2024/05/04/6636535363116.jpg" alt="Screenshot_20240504_215326.jpg"></p><h3 id="CF-Pages-ipv6-节点"><a href="#CF-Pages-ipv6-节点" class="headerlink" title="CF Pages ipv6 节点"></a>CF Pages ipv6 节点</h3><p>测速附图：</p><p><img src="https://bu.dusays.com/2024/05/04/663654a37a907.jpg" alt="Screenshot_20240504_232932.jpg"></p><p><img src="https://bu.dusays.com/2024/05/04/663654a4513c2.jpg" alt="Screenshot_20240504_233021.jpg"></p><p>目前我找到的只有两个节点，欢迎大佬补充</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2606:4700:310c::ac42:2ca5（估计是美国）</span><br><span class="line"></span><br><span class="line">2606:4700:310c::ac42:2f5b（估计是美国）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>cf workers 测试后发现节点在中国大陆几乎是墙的状态，节点来自脸书&#x2F;美国</p><p>暂时不推荐这种方法推荐使用netifly或pages服务</p><p>检测网站ipv6支持情况：</p><p><a href="https://ipw.cn/ipv6webcheck/?site=ipw.cn">https://ipw.cn/ipv6webcheck/?site=ipw.cn</a></p><p><a href="https://www.itdog.cn/http_ipv6/">https://www.itdog.cn/http_ipv6/</a></p><p>ipv6解析速度较慢，出现解析失败请耐心等待</p><p>这样你的静态网站就支持ipv6了<del>(¯▽¯</del>)~</p><p>补充：CF ipv6 节点列表</p><p><a href="https://stock.hostmonit.com/CloudFlareYesV6">https://stock.hostmonit.com/CloudFlareYesV6</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两年随着国家的大力支持，三大运营商已经开始普及IPv6，ipv6 的成本越来越低，为了紧跟时代步伐，不少网站已开启 IPv6 访问&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开启 IPv6，本期来讲讲如何为不支持 ipv6 的网站增加 ipv6 </summary>
      
    
    
    
    <category term="Cloudflare" scheme="https://blog.alcex.cn/categories/Cloudflare/"/>
    
    <category term="Vercel" scheme="https://blog.alcex.cn/categories/Vercel/"/>
    
    
    <category term="白嫖" scheme="https://blog.alcex.cn/tags/%E7%99%BD%E5%AB%96/"/>
    
    <category term="ipv6" scheme="https://blog.alcex.cn/tags/ipv6/"/>
    
    <category term="vercel" scheme="https://blog.alcex.cn/tags/vercel/"/>
    
    <category term="cloudflare" scheme="https://blog.alcex.cn/tags/cloudflare/"/>
    
  </entry>
  
  <entry>
    <title>gulp 详解与使用</title>
    <link href="https://blog.alcex.cn/posts/486480be/"/>
    <id>https://blog.alcex.cn/posts/486480be/</id>
    <published>2024-05-01T09:25:24.000Z</published>
    <updated>2024-05-04T08:18:46.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-gulp"><a href="#什么是-gulp" class="headerlink" title="什么是 gulp"></a>什么是 gulp</h1><p><a href="http://gulpjs.com/">gulp</a> 是一个前端构建工具，它能通过自动执行常见任务，比如编译预处理 CSS ，压缩 JavaScript 和刷新浏览器，来改进网站开发的过程，从而使开发更加快速高效。</p><h1 id="为什么要用-gulp"><a href="#为什么要用-gulp" class="headerlink" title="为什么要用 gulp"></a>为什么要用 gulp</h1><p>与 grunt 相比，gulp 无需写一大堆繁杂的配置参数，<a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md">API</a>（<a href="http://www.gulpjs.com.cn/docs/api/">中文 API</a>） 也非常简单，学习起来很容易，而且 gulp 使用的是 nodejs 中 <a href="https://nodejs.org/api/stream.html">stream</a> 来读取和操作数据，其速度更快。<br>gulp 有庞大的生态圈，且每天都在发展。依靠成千上万可供选择的插件，你可以利用 gulp 自动完成几乎任何事。</p><h1 id="如何使用-gulp"><a href="#如何使用-gulp" class="headerlink" title="如何使用 gulp"></a>如何使用 gulp</h1><h2 id="Installing-Gulp"><a href="#Installing-Gulp" class="headerlink" title="Installing Gulp"></a>Installing Gulp</h2><p>新版的 gulp 命令行工具已经改名为 gulp-cli 。<br>如果你之前安装了全局的 gulp 。在使用新的 gulp-cli 之前，执行命令<br><code>npm rm --global gulp</code> ，将之前的全局 gulp 卸掉。</p><span id="more"></span><h3 id="Install-the-gulp-command"><a href="#Install-the-gulp-command" class="headerlink" title="Install the gulp command"></a>Install the gulp command</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global gulp-cli</span><br></pre></td></tr></table></figure><h3 id="Install-gulp-in-your-devDependencies"><a href="#Install-gulp-in-your-devDependencies" class="headerlink" title="Install gulp in your devDependencies"></a>Install gulp in your devDependencies</h3><p>Run this command in your project directory</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev gulp</span><br></pre></td></tr></table></figure><h2 id="Create-a-gulpfile"><a href="#Create-a-gulpfile" class="headerlink" title="Create a gulpfile"></a>Create a gulpfile</h2><p>Create a file called gulpfile.js in your project root with these contents:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;default&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// place code for your default tash here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Test-it-out"><a href="#Test-it-out" class="headerlink" title="Test it out"></a>Test it out</h2><p>Run the gulp command in your projct directory:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp</span><br></pre></td></tr></table></figure><h1 id="gulp-API"><a href="#gulp-API" class="headerlink" title="gulp API"></a>gulp API</h1><p>gulp 的核心 API 有四个：gulp.task() 、 gulp.src() 、 gulp.dest() 、 gulp.watch() 。<br><a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md">gulp API</a><br><a href="http://www.gulpjs.com.cn/docs/api/">gulp API 中文</a></p><p>下面详细介绍一下：</p><h2 id="gulp-src"><a href="#gulp-src" class="headerlink" title="gulp.src()"></a>gulp.src()</h2><p>gulp.src() 可以读取你需要操作的文件，相比于 Grunt 主要以文件为媒介来运行它的工作流，gulp 使用的是 Nodejs 中的 <a href="https://nodejs.org/api/stream.html">stream</a> 流，首先获取到需要的 stream ，然后可以通过 stream 的 pipe() 方法把流导入到你想要的地方，比如 gulp 的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。所以 gulp 是以 stream 为媒介的，它不需要频繁的生成临时文件，这也是 gulp 的速度比 Grunt 快的一个原因。再回到正题上来，gulp.src() 方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流（Vinyl files），这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息，这个我们暂时不用去深入理解，你只需简单的理解可以用这个方法来读取你需要操作的文件就行了。其语法为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">src</span>(globs [, options])</span><br></pre></td></tr></table></figure><p>gulp 用到的 glob 的匹配规则以及一些文件匹配技巧。<br>gulp 内部使用了 node-glob 模块来实现其文件匹配功能。我们可以使用下面这些特殊的字符来匹配我们想要的文件：</p><ul><li><code>*</code> 匹配文件路径中的 0 个或多个字符，但不会匹配路径分配符，除非路径分隔符出现在末尾</li><li>** 匹配路径中的 0 个或多个目录及其子目录，需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。</li><li>? 匹配文件路径中的一个字符（不会匹配路径分隔符）</li><li>[…] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为 ^ 或 ! 时，则表示不匹配方括号中出现的其他字符中的任意一个，类似 js 正则表达式中的用法。</li><li>!(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的</li><li>?(pattern|pattern|pattern) 匹配括号中给定的任一模式 0 次或 1 次，类似于 js 正则中的(pattern|pattern|pattern)?</li><li>+(pattern|pattern|pattern) 匹配括号中给定的任一模式至少 1 次，类似于正则中的(pattern|pattern|pattern)+</li><li><code>*(pattern|pattern|pattern)</code> 匹配括号中的给定的任一模式 0 次或多次，类似于 js 正则中的 <code>(pattern|pattern|pattern)*</code></li><li>@(pattern|pattern|pattern) 匹配括号中给定的任一模式 1 次，类似于 js 正则中的(pattern|pattern|pattern)</li></ul><p>下面以一系列例子来加深理解</p><ul><li><code>*</code> 能匹配 a.js 、 x.y 、 abc 、 abc&#x2F; ，但不能匹配 a&#x2F;b.js</li><li><code>*.*</code> 能匹配 a.js 、 style.css 、 a.b 、 x.y</li><li><code>*/*/*.js</code> 能匹配 a&#x2F;b&#x2F;c.js 、 x&#x2F;y&#x2F;z.js ，不能匹配 a&#x2F;b.js 、a&#x2F;b&#x2F;c&#x2F;d.js</li><li>** 能匹配 abc 、 a&#x2F;b.js 、 a&#x2F;b&#x2F;c.js 、 x&#x2F;y&#x2F;z 、x&#x2F;y&#x2F;z&#x2F;a.b ，能用来匹配所有的目录和文件</li><li>**&#x2F;*.js 能匹配 foo.js 、 a&#x2F;foo.js 、 a&#x2F;b&#x2F;foo.js 、 a&#x2F;b&#x2F;c&#x2F;foo.js</li><li>a&#x2F;**&#x2F;z 能匹配 a&#x2F;z 、 a&#x2F;b&#x2F;z 、 a&#x2F;b&#x2F;c&#x2F;z 、 a&#x2F;d&#x2F;g&#x2F;h&#x2F;r&#x2F;z</li><li><code>a/**b/z</code> 能匹配 a&#x2F;b&#x2F;z 、 a&#x2F;fb&#x2F;z ，但不能匹配 a&#x2F;x&#x2F;gb&#x2F;z ，因为只有单 ** 单独出现才能匹配多级目录</li><li>?.js 能匹配 a.js 、 b.js 、 c.js</li><li>a?? 能匹配 a.b 、 abc ，但不能匹配 ab&#x2F; ，因为它不会匹配路径分隔符</li><li>[xyz].js 只能匹配 x.js 、 y.js 、 z.js ，不会匹配 xy.js 、 xyz.js 等，整个中括号只代表一个字符</li><li>[^xyz].js 能匹配 a.js 、 b.js 、 c.js 等，不能匹配 x.js 、 y.js 、 z.js</li></ul><p>当有多种匹配模式时可以使用数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用数组的方式来匹配多种文件</span></span><br><span class="line">gulp.<span class="title function_">src</span>([<span class="string">&#x27;js/*.js&#x27;</span>,<span class="string">&#x27;css/*.css&#x27;</span>,<span class="string">&#x27;*.html&#x27;</span>])</span><br></pre></td></tr></table></figure><p>使用数组的方式还有一个好处就是可以很方便的使用排除模式，在数组中的单个匹配模式前加上 ! 即是排除模式，它会在匹配的结果中排除这个匹配，要注意一点的是不能在数组中的第一个元素中使用排除模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">src</span>([*.<span class="property">js</span>,<span class="string">&#x27;!b*.js&#x27;</span>])  <span class="comment">//匹配所有 js 文件，但排除掉以 b 开头的 js 文件</span></span><br><span class="line">gulp.<span class="title function_">src</span>([<span class="string">&#x27;!b*.js&#x27;</span>,*.<span class="property">js</span>])  <span class="comment">//不会排除任何文件，因为排除模式不能出现在数组的第一个元素中</span></span><br></pre></td></tr></table></figure><p>此外，还可以使用展开模式。展开模式以花括号作为定界符，根据它里面的内容，会展开为多个模式，最后匹配的结果为所有展开的模式想加起来得到的结果。展开的例子如下：</p><ul><li>a{b,c}d 会展开为 abd 、 acd</li><li>a{b,}c 会展开为 abc 、 ac</li><li>a{0..3}d 会展开为 a0d 、 a1d 、 a2d 、 a3d</li><li>a{b,c{d,e}f}g 会展开为 abg 、 acdfg 、 acefg</li><li>a{b,c}d{e,f}g 会展开为 abdeg 、 acdeg 、 abdfg 、 abdeg</li></ul><h2 id="gulp-dest"><a href="#gulp-dest" class="headerlink" title="gulp.dest()"></a>gulp.dest()</h2><p>gulp.dest() 方法是用来写文件的，其语法为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">dest</span>(path[, options])</span><br></pre></td></tr></table></figure><p><strong>path</strong> 为写入文件的路径<br>我们给 gulp.dest() 传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名，所以生成的文件名是由导入到它的文件流决定的，即使我们给它传入一个带有文件名的路径参数，然后它也会把这个文件名当作是目录名，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&quot;gulp&quot;</span>);</span><br><span class="line">gulp.<span class="title function_">src</span>(<span class="string">&quot;script/jquery.js&quot;</span>).<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&quot;dist/foo.js&quot;</span>));</span><br><span class="line"><span class="comment">// 最终生成的文件路径为 dist/foo.js/jquery.js ，而不是 dist/foo.js</span></span><br></pre></td></tr></table></figure><p>要想改变文件名，可以使用插件 gulp-rename<br>下面说说生成的文件路径与我们给 gulp.dest() 方法传入的路径参数之间的关系。<br>gulp.dest(path) 生成的文件路径是我们传入的 path 参数后面再加上 gulp.src() 中有通配符开始出现的那部分路径。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&quot;gulp&quot;</span>);</span><br><span class="line"><span class="comment">//有通配符开始出现的那部分路径为 **/*.js</span></span><br><span class="line">gulp.<span class="title function_">src</span>(<span class="string">&quot;script/**/*.js&quot;</span>).<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&quot;dist&quot;</span>));</span><br><span class="line"><span class="comment">//最后生成的文件路径为 dist/**/*.js</span></span><br><span class="line"><span class="comment">//如果 **/*.js 匹配到的文件为 jquery/jquery.js ，则生成的文件路径为 dist/jquery/jquery.js</span></span><br></pre></td></tr></table></figure><p>再举更多一点的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">src</span>(<span class="string">&quot;script/avalon/avalon.js&quot;</span>).<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&quot;dist&quot;</span>));</span><br><span class="line"><span class="comment">//没有通配符出现的情况，最后生成的文件路径为 dist/avalon.js</span></span><br><span class="line"></span><br><span class="line">gulp.<span class="title function_">src</span>(<span class="string">&quot;script/**/underscore.js&quot;</span>).<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&quot;dist&quot;</span>));</span><br><span class="line"><span class="comment">//有通配符开始出现的那部分路径为 **/underscore.js</span></span><br><span class="line"><span class="comment">//假设匹配到的文件为script/util/underscore.js</span></span><br><span class="line"><span class="comment">//则最后生成的文件路径为dist/util/underscore.js</span></span><br><span class="line"></span><br><span class="line">gulp.<span class="title function_">src</span>(<span class="string">&quot;script/*&quot;</span>).<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&quot;dist&quot;</span>));</span><br><span class="line"><span class="comment">//有通配符出现的那部分路径为*</span></span><br><span class="line"><span class="comment">//假设匹配到的文件为script/zepto.js</span></span><br><span class="line"><span class="comment">//则最后生成的文件路径为dist/zepto.js</span></span><br></pre></td></tr></table></figure><p>通过指定 gulp.src() 方法配置参数中的 base 属性，我们可以灵活的来改变 gulp.dest() 生成的文件路径。<br>当我们没有在 gulp.src() 方法配置参数中的 base 属性，base 的默认值为通配符开始出现之前那部分路径，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">src</span>(<span class="string">&quot;app/src/**/*.css&quot;</span>) <span class="comment">//此时base的值为 app/src</span></span><br></pre></td></tr></table></figure><p>上面我们说的 gulp.dest() 所生成的文件路径的规则，其实也可以理解成，用我们给 gulp.dest() 传入的路径替换掉 gulp.src() 中的 base 路径，最终得到生成文件的路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">src</span>(<span class="string">&quot;app/src/**/*.css&quot;</span>).<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&quot;dist&quot;</span>));</span><br><span class="line"><span class="comment">//此时base的值为app/src，也就是说它的base路径为app/src</span></span><br><span class="line"><span class="comment">//设该模式匹配到了文件app/src/css/normal.css</span></span><br><span class="line"><span class="comment">//用dist替换掉base路径，最终得到dist/css/normal.css</span></span><br></pre></td></tr></table></figure><p>所以改变 base 路径后，gulp.dest() 生成的文件路径也会改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">src</span>(<span class="string">&quot;script/lib/*.js&quot;</span>).<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&quot;build&quot;</span>));</span><br><span class="line"><span class="comment">//没有配置base参数，此时默认的base路径为script/lib</span></span><br><span class="line"><span class="comment">//假设匹配到的文件为script/lib/jquery.js</span></span><br><span class="line"><span class="comment">//生成的文件路径为build/jquery.js</span></span><br><span class="line"></span><br><span class="line">gulp.<span class="title function_">src</span>(<span class="string">&quot;script/lib/*.js&quot;</span>, &#123;<span class="attr">base</span>: <span class="string">&quot;script&quot;</span>&#125;).<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&quot;build&quot;</span>));</span><br><span class="line"><span class="comment">//配置了base参数，此时base路径为script</span></span><br><span class="line"><span class="comment">//假设匹配到的文件为script/lib/jquery.js</span></span><br><span class="line"><span class="comment">//此时生成的文件路径为build/lib/jquery.js</span></span><br></pre></td></tr></table></figure><p>用 gulp.dest() 把文件流写入文件后，文件流仍然可以继续使用。</p><h2 id="gulp-task"><a href="#gulp-task" class="headerlink" title="gulp.task()"></a>gulp.task()</h2><p>gulp.task 方法用来定义任务，内部使用的是 Orchestrator ，其语法为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(name[, deps], fn)</span><br></pre></td></tr></table></figure><p><strong>name</strong> 为任务名，如果你需要在命令行中运行你的某些任务，那么，请不要在名字中使用空格。<br><strong>deps</strong> 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数。<br><strong>fn</strong> 为任务函数，我们把任务要执行的代码都要写在里面。该参数也是可选的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&quot;mytask&quot;</span>, [<span class="string">&quot;array&quot;</span>, <span class="string">&quot;of&quot;</span>, <span class="string">&quot;task&quot;</span>, <span class="string">&quot;names&quot;</span>], <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//定义一个有依赖的任务</span></span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关于 gulp.task() ，我们需要知道执行多个任务时怎么来控制任务执行的顺序。<br>gulp 中执行多个任务，可以通过任务依赖来实现。例如我想要执行 one ，two ，three 这三个任务，那我们就可以定义一个空的任务，然后把那三个任务当做这个空的任务的依赖就行了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只要执行default任务，就相当于把one,two,three这三个任务执行了</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;default&#x27;</span>,[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>如果任务相互之间没有依赖，任务会按你书写的顺序来执行，如果有依赖的话则会先执行依赖的任务。<br>但是如果某个任务所依赖的任务是异步的，就要注意了，gulp 并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;one&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// one是一个异步执行的任务</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;one is done&quot;</span>);</span><br><span class="line">  &#125;,<span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//two任务虽然依赖于one任务，但并不会等到one任务中的异步操作完成后再执行</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&quot;two&quot;</span>, [<span class="string">&quot;one&quot;</span>], <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;two is done&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i-s1.hydun.com/6/2024/05/02/663393a93fa9a.png"><br>上面的例子中我们执行 two 任务时，会先执行 one 任务，但不会去等待 one 任务中的异步操作完成后再执行 two 任务，而是紧接着执行 two 任务。因为 one 任务耗时 3 秒，所以 two 任务会在 one 任务中的异步操作完成之前就执行了。</p><p>那如果我们想等待异步任务中的异步操作完成后再执行后续的任务，该怎么做呢？<br>有三种方法可以实现：</p><p>第一：在异步操作完成后执行一个回调函数来通知 gulp 这个异步任务已经完成，这个回调函数就是任务函数的第一个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&quot;one&quot;</span>, <span class="keyword">function</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">  <span class="comment">//cb为任务函数提供的回调，用来通知任务已经完成</span></span><br><span class="line">  <span class="comment">//one是一个异步执行的任务</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;one is done&quot;</span>);</span><br><span class="line">    <span class="title function_">cb</span>(); <span class="comment">//执行回调，表示这个异步任务已经完成</span></span><br><span class="line">  &#125;,<span class="number">5000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这时two任务会在one任务中的异步操作完成后再执行</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&quot;two&quot;</span>, [<span class="string">&quot;one&quot;</span>], <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;two is done&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第二：定义任务时返回一个流对象。适用于任务就是操作 gulp.src 获取到的流的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&quot;one&quot;</span>, <span class="keyword">function</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> stream = gulp.<span class="title function_">src</span>(<span class="string">&quot;client/**/*.js&quot;</span>)</span><br><span class="line">      .<span class="title function_">pipe</span>(<span class="title function_">dosomething</span>()) <span class="comment">//dosomething()中有某些异步操作</span></span><br><span class="line">      .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&quot;build&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> stream;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是two任务会在one任务中的异步操作完成后再执行</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&quot;two&quot;</span>, [<span class="string">&quot;one&quot;</span>], <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;two is done&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第三：返回一个 promise 对象，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">&#x27;q&#x27;</span>); <span class="comment">//一个著名的异步处理的库 https://github.com/kriskowal/q</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&quot;one&quot;</span>, <span class="keyword">function</span>(<span class="params">cb</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> deferred = Q.<span class="title function_">defer</span>();</span><br><span class="line">  <span class="comment">//做一些异步操作</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    deferred.<span class="title function_">resolve</span>();</span><br><span class="line">  &#125;,<span class="number">5000</span>);</span><br><span class="line">  <span class="keyword">return</span> deferred.<span class="property">promise</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&quot;two&quot;</span>, [<span class="string">&quot;one&quot;</span>], <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;two is done&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关于 gulp.task() ，主要的就是要清除当依赖异步任务时要如何处理。</p><h2 id="gulp-watch"><a href="#gulp-watch" class="headerlink" title="gulp.watch()"></a>gulp.watch()</h2><p>gulp.watch() 用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">watch</span>(glob[, opts], tasks);</span><br></pre></td></tr></table></figure><p><strong>glob</strong> 为要监视的文件匹配模式，规则和用法与 gulp.src() 方法中的 glob 相同。<br><strong>opts</strong> 为一个可选的配置对象，通常不需要用到。<br><strong>tasks</strong> 为文件变化后要执行的任务，为一个数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&quot;uglify&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;);</span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&quot;reload&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;);</span><br><span class="line">gulp.<span class="title function_">watch</span>(<span class="string">&quot;js/**/*.js&quot;</span>, [<span class="string">&quot;uglify&quot;</span>,<span class="string">&quot;reload&quot;</span>]);</span><br></pre></td></tr></table></figure><p>gulp.watch(glob [,opts, cb])<br><strong>glob</strong> 和 <strong>opts</strong> 参数与第一种用法相同<br><strong>cb</strong> 参数为一个函数。每当监视的文件发生变化时，就会调用这个函数，并且会给它传入一个对象，该对象包含了文件变化的一些信息，type 属性为变化的类型，可以是 added 、changed 、deleted ，path 属性为发生变化的文件的路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">watch</span>(<span class="string">&quot;js/**/*.js&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>); <span class="comment">//变化类型added为新增，deleted为删除，changed为改变</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">path</span>); <span class="comment">//变化的文件的路径</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="gulp-的插件"><a href="#gulp-的插件" class="headerlink" title="gulp 的插件"></a>gulp 的插件</h1><p>gulp 本身虽然不能完成很多任务，但它有大量插件可用，我们可以在 <a href="http://gulpjs.com/plugins/">插件页面</a> 或者在 npm 搜索 gulpplugin 。<br>列一些很棒的 plugin ：</p><ul><li><a href="https://www.npmjs.com/package/gulp-jshint/">JSHint</a> ： js代码检查分析工具</li><li><a href="https://www.npmjs.com/package/gulp-coffee/">gulp-coffee</a> ： 编译CoffeeScript</li><li><a href="https://www.npmjs.com/package/gulp-mocha">gulp-mocha</a> ： 执行Mocha测试</li><li><a href="https://www.npmjs.com/package/gulp-bump">gulp-bump</a> ： 更新版本号</li><li><a href="https://www.npmjs.com/package/gulp-sass">gulp-sass</a> ： sass 编译</li><li><a href="http://www.browsersync.cn/docs/gulp/">browser-sync</a> ： 浏览器自动刷新</li><li><a href="https://www.npmjs.com/package/gulp-uglify">gulp-uglify</a> ： 代码压缩</li><li><a href="https://www.npmjs.com/package/gulp-concat">gulp-concat</a> ： 合并</li><li><a href="https://www.npmjs.com/package/gulp-eslint">gulp-eslint</a> ： 支持 ES6 JSX</li></ul><h1 id="gulp-命令行参数"><a href="#gulp-命令行参数" class="headerlink" title="gulp 命令行参数"></a>gulp 命令行参数</h1><ul><li><code>-v</code> 或 <code>--version</code> 会显示全局和项目本地所安装的 gulp 版本号</li><li><code>--require &lt;module path&gt;</code> 将会在执行之前 require 一个模块。这对于一些语言编译器或者需要其他应用的情况来说很有用。你可以使用多个 <code>--require</code></li><li><code>--gulpfile &lt;gulpfile path&gt;</code> 手动指定一个 gulpfile 的路径，这在你有很多个 gulpfile 的时候很有用。这也会将 CWD 设置到该 gulpfile 所在目录</li><li><code>--cwd &lt;dir path&gt;</code> 手动指定 CWD 。定义 gulpfile 查找的位置，此外，所有的相应的依赖（require）会从这里开始计算相对路径</li><li><code>-T</code> 或 <code>--tasks</code> 会显示所指定 gulpfile 的 task 依赖树</li><li><code>--tasks-simple</code> 会以纯文本的方式显示所载入的 gulpfile 中的 task 列表</li><li><code>--color</code> 强制 gulp 和 gulp 插件显示颜色，即便没有颜色支持</li><li><code>--no-color</code> 强制不显示颜色，即便检测到有颜色支持</li><li><code>--silent</code> 禁止所有的 gulp 日志</li></ul><p>命令行会在 process.env.INIT_CW 中记录它是从哪里被运行的。</p><h1 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h1><p>1、gulp 写进项目 package.json 文件的依赖有什么作用<br>方便别人查看你项目中有些什么依赖，而且在项目目录下执行 npm install 命令会安装项目 package.json 中的所有依赖模块，这样就能简化项目的安装程序了，不用一个一个模块去安装啊。</p><p>2、gulp 中着重了解 gulp.task() 如何处理依赖任务是耗时操作或者异步操作的情况。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是-gulp&quot;&gt;&lt;a href=&quot;#什么是-gulp&quot; class=&quot;headerlink&quot; title=&quot;什么是 gulp&quot;&gt;&lt;/a&gt;什么是 gulp&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://gulpjs.com/&quot;&gt;gulp&lt;/a&gt; 是一个前端构建工具，它能通过自动执行常见任务，比如编译预处理 CSS ，压缩 JavaScript 和刷新浏览器，来改进网站开发的过程，从而使开发更加快速高效。&lt;/p&gt;
&lt;h1 id=&quot;为什么要用-gulp&quot;&gt;&lt;a href=&quot;#为什么要用-gulp&quot; class=&quot;headerlink&quot; title=&quot;为什么要用 gulp&quot;&gt;&lt;/a&gt;为什么要用 gulp&lt;/h1&gt;&lt;p&gt;与 grunt 相比，gulp 无需写一大堆繁杂的配置参数，&lt;a href=&quot;https://github.com/gulpjs/gulp/blob/master/docs/API.md&quot;&gt;API&lt;/a&gt;（&lt;a href=&quot;http://www.gulpjs.com.cn/docs/api/&quot;&gt;中文 API&lt;/a&gt;） 也非常简单，学习起来很容易，而且 gulp 使用的是 nodejs 中 &lt;a href=&quot;https://nodejs.org/api/stream.html&quot;&gt;stream&lt;/a&gt; 来读取和操作数据，其速度更快。&lt;br&gt;gulp 有庞大的生态圈，且每天都在发展。依靠成千上万可供选择的插件，你可以利用 gulp 自动完成几乎任何事。&lt;/p&gt;
&lt;h1 id=&quot;如何使用-gulp&quot;&gt;&lt;a href=&quot;#如何使用-gulp&quot; class=&quot;headerlink&quot; title=&quot;如何使用 gulp&quot;&gt;&lt;/a&gt;如何使用 gulp&lt;/h1&gt;&lt;h2 id=&quot;Installing-Gulp&quot;&gt;&lt;a href=&quot;#Installing-Gulp&quot; class=&quot;headerlink&quot; title=&quot;Installing Gulp&quot;&gt;&lt;/a&gt;Installing Gulp&lt;/h2&gt;&lt;p&gt;新版的 gulp 命令行工具已经改名为 gulp-cli 。&lt;br&gt;如果你之前安装了全局的 gulp 。在使用新的 gulp-cli 之前，执行命令&lt;br&gt;&lt;code&gt;npm rm --global gulp&lt;/code&gt; ，将之前的全局 gulp 卸掉。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://blog.alcex.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="gulp" scheme="https://blog.alcex.cn/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>使用 Github Action 自动化部署 hexo</title>
    <link href="https://blog.alcex.cn/posts/2023429a1/"/>
    <id>https://blog.alcex.cn/posts/2023429a1/</id>
    <published>2023-04-29T02:19:03.000Z</published>
    <updated>2024-04-05T11:06:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前一段时间从hexo换到了WordPress，用了一年最后换回了hexo，用GitHub action折腾了一个hexo自动化部署，挺方便的</p><h3 id="Github-Action"><a href="#Github-Action" class="headerlink" title="Github Action"></a>Github Action</h3><p>GItHub Actions是一个持续集成和持续交付的平台，能够让你自动化你的编译、测试和部署流程。</p><p>GitHub 提供 Linux、Windows 和 macOS 虚拟机来运行您的工作流程，或者您可以在自己的数据中心或云基础架构中托管自己的自托管运行器</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可以多域名多站点部署</li><li>不会出现连接 github 连接不上的情况</li><li>可以自动部署完成</li><li>不再需要使用繁杂的命令</li></ul><h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>在这里分享一下我的工作流，平时写完文章以后，提交到仓库就会自动部署、更新<br>，工作流部署后可使用GitHub Pages，netlify，vercel，cloudflare pages等，实现多线路多域名</p><h4 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h4><p>首先新建仓库A，用于一会儿hexo生成网页文件的存储仓库格式可以是 <code>xxx.github.io</code>，再新建仓库B(建议改为 <code>私有</code>)将博客源码上传至仓库<br>，找到Actions，点击”set up a workflow yourself “新建工作流<br><img src="https://pan.alcex.top/d/WebDav/img/Screenshot_20230429_205838_com.microsoft.emmx_edit_61999468448351.jpg?sign=7vTAp1PRD9V78mcA2AUgenBw-8jGq4KU-iycVhTwcyE=:0" alt="action"><br>输入以下代码:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">自动部署</span></span><br><span class="line"><span class="comment"># 当有改动推送到main分支时启动Action</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line">      <span class="comment">#根据自己仓库的情况进行更改(源码在哪一分支就填哪个)</span></span><br><span class="line">  <span class="attr">release:</span></span><br><span class="line">    <span class="attr">types:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">published</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">检查分支</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">main</span></span><br><span class="line">          <span class="attr">fetch-depth:</span> <span class="number">0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Sync</span> <span class="string">local</span> <span class="string">file</span> <span class="string">timestamps</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          git ls-files -z | while read -d &#x27;&#x27; path; do touch -d $(git log -1 --format=&quot;@%ct&quot; &quot;$path&quot;) &quot;$path&quot;; done</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">Node</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;16.x&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          export TZ=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="string">          npm install hexo-cli -g</span></span><br><span class="line"><span class="string"></span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">缓存</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">cache-npm</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v3</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">cache-name:</span> <span class="string">cache-node-modules</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-build-$&#123;&#123;</span> <span class="string">env.cache-name</span> <span class="string">&#125;&#125;-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.os &#125;&#125;-build-</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.os &#125;&#125;-</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装依赖</span></span><br><span class="line">        <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.cache-npm.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">&#x27;true&#x27;</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install gulp-cli -g #全局安装gulp</span></span><br><span class="line"><span class="string">          npm install --save</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">生成静态文件</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          hexo clean</span></span><br><span class="line"><span class="string">          hexo generate</span></span><br><span class="line"><span class="string">          gulp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">部署到Github</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          cd ./public</span></span><br><span class="line"><span class="string">          git init</span></span><br><span class="line"><span class="string">          git config --global user.name &quot;xxx&quot;</span></span><br><span class="line"><span class="string">          git config --global user.email &quot;xxx@xxx.com&quot;</span></span><br><span class="line"><span class="string">          git add .</span></span><br><span class="line"><span class="string">          git commit -m &#x27;$&#123;&#123; github.event.head_commit.message &#125;&#125;&#x27;</span></span><br><span class="line"><span class="string">          git push --force --all https://user:token@github.com/user/user.github.io</span></span><br></pre></td></tr></table></figure><hr><ul><li>注意!⚠️将 git config –global user.name “xxx”中的 xxx 替换为您的 GitHub 用户名(不是昵称)</li><li>注意!⚠️将 git config –global user.email “<a href="mailto:&#120;&#x78;&#120;&#x40;&#120;&#x78;&#120;&#x2e;&#x63;&#x6f;&#x6d;">&#120;&#x78;&#120;&#x40;&#120;&#x78;&#120;&#x2e;&#x63;&#x6f;&#x6d;</a>“中的 <a href="mailto:&#x78;&#120;&#x78;&#x40;&#x78;&#x78;&#120;&#46;&#x63;&#x6f;&#109;">&#x78;&#120;&#x78;&#x40;&#x78;&#x78;&#120;&#46;&#x63;&#x6f;&#109;</a> 替换为您的 GitHub <code>主邮箱</code></li><li>注意!⚠️ git push –force –all <a href="https://user:token@github.com/user/user.github.io">https://user:token@github.com/user/user.github.io</a> 中 第一个 user 替换为您的用户名，token 替换为您的 GitHub token 如没有请在 <code>设置</code>页面中创建。<br>再将 github.com 后的 <code>user</code>改为您的用户名，后面的 <code>user.github.io</code>改为您将要存储博客网页的仓库名。</li></ul><h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><h4 id="添加屏蔽项"><a href="#添加屏蔽项" class="headerlink" title="添加屏蔽项"></a>添加屏蔽项</h4><p>因为能够使用指令进行安装的内容不包括在需要提交的源码内，所有我们需要将这些内容添加到屏蔽项，表示不上传到 github 上。这样可以显著减少需要提交的文件量和加快提交速度。打开 <code>.gitignore</code>,(没有请创建)输入以下内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">.deploy_git*/</span><br><span class="line">.idea</span><br><span class="line">themes/butterfly/.git</span><br></pre></td></tr></table></figure><p>最后一行要改成实际.git 的位置，因为我是 butterfly 主题，不同主题文件夹名字各不相同！<br>如果不是butterfly主题，记得替换最后一行内容为你自己当前使用的主题。</p><h4 id="查看部署情况"><a href="#查看部署情况" class="headerlink" title="查看部署情况"></a>查看部署情况</h4><p>打开 Github 存放源码的私有仓库，找到 action<br><img src="https://pan.alcex.top/d/WebDav/img/07_edit_63885251194938.png?sign=4XjVRPA6CAKnkEptA1AgrPXV5WaqbQeQUhF0Mbc9Ssw=:0" alt="02"><br>根据刚刚的 Commit 记录找到相应的部署日志，点击 Deploy 查看部署情况<br><img src="https://pan.alcex.top/d/WebDav/img/09_edit_63916524348058.png?sign=pw0QRkIq_Tw5icSAv28W1Oh_P9w1QxN9npU4zpVA9dE=:0" alt="03"><br>若全部打钩，恭喜你，你现在可以享受自动部署了</p>]]></content>
    
    
    <summary type="html">本文主要讲解如何使用 GitHub Action 自动化部署 hexo 博客</summary>
    
    
    
    <category term="hexo" scheme="https://blog.alcex.cn/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://blog.alcex.cn/tags/hexo/"/>
    
    <category term="Github Action" scheme="https://blog.alcex.cn/tags/Github-Action/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blog.alcex.cn/posts/16107/"/>
    <id>https://blog.alcex.cn/posts/16107/</id>
    <published>2022-05-04T08:09:41.749Z</published>
    <updated>2024-05-04T08:09:41.749Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
